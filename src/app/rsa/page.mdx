---
title: "Understanding RSA"
description: "A deep dive into the mathematics of the RSA encryption algorithm, focusing on number theory."
---

import CalloutBox from "@/components/CalloutBox";
import MathBlock from "@/components/MathBlock";

# Understanding RSA

RSA is one of the first public-key encryption algorithms used and, for this reason, serves very well as a pedagogical example to the curious reader who wants to explore **cryptography**.

In this post I intend to focus more on the mathematical side of it, specifically **number theory**.

Let's begin by understanding the system. RSA uses a pair of keys: one **public**, which can be shared openly, and one **private**, which must be kept secret by its owner.

The standard example involves Bob and Alice exchanging messages. Since they want to encrypt their communication using RSA, each of them has a key pair.

Secure of the system, Alice wants to send a message to Bob. She uses Bob’s **public key** to **encrypt** the message.

At this point Bob, <u>and Bob only</u>, will then be able to **decrypt** the message and read it, by using his private-key

The security of this system relies on the fact that Bob’s private key is known only to him. The algorithm ensures that messages encrypted with the public key can only be decrypted using the corresponding private key in a mathematically elegant and fascinating way.

Generating such public/private key pairs involves fundamental number theory concepts, particularly **prime numbers**. You may recall that a prime number is a number divisible only by itself and 1.

Generating such public/private key pairs involves fundamental number theory concepts, particularly **prime numbers**. You may recall that a prime number is a **natural number** (positive integer) greater than 1 and divisible only by itself and 1.

<CalloutBox type="example" title="Prime factorization">
  3 and 7 are prime numbers, while 21 is not. It can be expressed as a product of primes: 3 × 7.
</CalloutBox>

The primes are the atoms of natural numbers. Each natural number can be constructed as a product of primes (factorization). This factorization is unique, up to the order of the factors.

<CalloutBox type="example" title="Prime factorization">
  <MathBlock latex="21 = 3 	imes 7" displayMode={false} />
</CalloutBox>

This is stated as an important **theorem** called **Fundamental Theorem of Arithmetic** or **Unique Factorization Theorem**, in short **UFT**.

<CalloutBox type="theorem" title="Unique Factorization Theorem">
  Every natural number can be uniquely factorized, (up to ordering) by it's **prime facrtors**
</CalloutBox>

<CalloutBox type="remark" title="">
  Notice that 1 is not a included in the statement of the theorem, as it can be seen as a product of no primes.
</CalloutBox>

Here another example of prime factorization:

<CalloutBox type="example" title="Prime factorization">
  <MathBlock latex="6615 = 3^3 	imes 7^2 	imes 5" displayMode={false} />
</CalloutBox>

Let's get back to the key generation process. The RSA algorithm generates a pair of keys using the following steps:

<CalloutBox type="definition" title="RSA Key Generation">
  <ol>
    <li>
      Choose two primes: <code>p</code> and <code>q</code>
    </li>
    <li>
      Compute <code>n = p × q</code>
    </li>
    <li>Compute φ(n) = (p−1)(q−1)</li>
    <li>
      Choose <code>e</code> such that <code>1 &lt; e &lt; φ(n)</code> and <code>gcd(e, φ(n)) = 1</code>
    </li>
    <li>
      Find <code>d</code> such that <code>e × d ≡ 1 mod φ(n)</code>
    </li>
  </ol>
</CalloutBox>

This is probably not very clear, since i haven't most of concepts. Let's break it down step by step.

## Step 1: Choose two primes

The first step is to choose two distinct prime numbers, `p` and `q`. These primes should be large enough (at least 20 digits) to ensure the security of the RSA system. The larger the primes, the more secure the key pair will be. Is indeed notoriusly difficult to factorize the product of two large primes, which is the basis of RSA's security. This fact migh be problematicin quantum computing.

## Step 2: Compute `n = p × q`

In this simple `n` will be the private key, p and q are must be kept secret.

## Step 3: Compute `φ(n) = (p−1)(q−1)`

Now here it's where things get more complicated. We introduce `φ(n)` called the **Euler's totient function** and it counts the number of integers up to `n` that are coprime to `n`.

<CalloutBox type="definition" title="Euler's totient function">
  Given a positive integeer n, the totient function φ(n), counts the number of integers from 0 to n-1 that are coprime to `n`. By convention φ(1) = 1.
</CalloutBox>

<CalloutBox type="example" title="">
  <code>φ(12) = 4</code>. Since the integers 1, 5, 7, and 11 are coprime to 12.
</CalloutBox>

Ok wait but what does it mean to be coprime? Well for now we can say that two positive integers are **coprime** if they have no common prime factors other than 1.

In particular if `n` is a prime number, then `φ(n) = n - 1`. Why?

Morover if p and q are coprime (notice that our p and q are distinct primes), it follows that `φ(n) = (p−1)(q−1)`. Concluding review os step 3.

## Step 4: Choose `e` such that `1 < e < φ(n)` and syuch that e is coprime to `φ(n)`( `gcd(e, φ(n)) = 1` )

Chooding `e` such that `1 < e < φ(n)` should be clear. Anyway, in order to determine that this two positive integers are coprime, we introduce the gcd and claim two integers are coprime iff (`gcd(e, φ(n)) = 1`).

<CalloutBox type="definition" title="GCD">
  The **greatest common divisor** (gcd) of two integers is the largest positive integer that divides both numbers without leaving a remainder.
</CalloutBox>

<CalloutBox type="example" title="GCD">
  The gcd of 12 and 15 is 3, since 3 is the largest number that divides both without a remainder.
</CalloutBox>

To compute the gcd of two integers, we can use the **Euclidean algorithm** descibed in "Elements" around 300 BC (yesd one of the oldest and still useg algorithm), It's an efficient method for finding the gcd of two numbers. The algorithm is based on the principle that the gcd of two numbers also divides their difference and thus i a recursive algorithm! The algorithm works as follows:

1. Take two integers `a` and `b`.
2. If `b` is 0, then the gcd is `a`.
3. Otherwise, replace `a` with `b` and `b` with `a % b` (the remainder of the division of `a` by `b`).
4. Repeat steps 2 and 3 until `b` becomes 0.

The gcd is the last non-zero remainder, which is the largest positive integer that divides both `a` and `b`.

```javascript
function gcd(a, b) {
  return b === 0 ? a : gcd(b, a % b);
}
```

Now we can thus define when two integers are coprime:

<CalloutBox type="definition" title="Coprime">
  Two integers are coprime if their greatest common divisor (gcd) is 1.
</CalloutBox>

<CalloutBox type="example" title="Coprime">
  The integers 8 and 15 are coprime because their gcd is 1, meaning they have no common prime factors.
</CalloutBox>
