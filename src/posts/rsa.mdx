import CalloutBox from "@/components/CalloutBox";

# Understanding RSA

RSA is one of the first public-key encryption algorithms ever used. For this reason, it serves well as a pedagogical example for readers curious about **cryptography**.

In this post, I‚Äôll focus more on the mathematical aspects of RSA ‚Äî specifically **number theory**.

Let‚Äôs begin by understanding the system. RSA relies on a **pair of keys**: one **public**, which can be shared openly, and one **private**, which must be kept secret by its owner.

The standard example involves Bob and Alice exchanging messages.  
Since they want to encrypt their communication using RSA, each of them has such a key pair.

Confident in the system, Alice wants to send a message to Bob. She uses Bob‚Äôs **public key** to **encrypt** the message.

At this point, Bob ‚Äî <u>and Bob only</u> ‚Äî can **decrypt** the message using his **private key**.

The security of this system relies on the fact that Bob‚Äôs private key is known only to him.  
The algorithm ensures that messages encrypted with the public key can only be decrypted using the corresponding private key ‚Äî in a mathematically elegant way known as **modular arithmetic**.

---

Generating such public/private key pairs involves fundamental number theory concepts, particularly **prime numbers**.  
You may recall that a prime number is a **natural number** (positive integer) greater than 1, divisible only by 1 and itself.

<CalloutBox type="example" title="Prime factorization">
  3 and 7 are prime numbers, while 21 is not. It can be expressed as a product
  of primes: 3 √ó 7.
</CalloutBox>

Prime numbers are the **atoms** of natural numbers. Every natural number can be constructed as a product of primes (factorization).  
This factorization is **unique**, up to the order of the factors.

<CalloutBox type="example" title="Prime factorization">
  $21 = 7 \times 3$ or $3 \times 7$
</CalloutBox>

This is formalized in a famous result known as the **Fundamental Theorem of Arithmetic**, or **Unique Factorization Theorem (UFT)**.

<CalloutBox type="theorem" title="Unique Factorization Theorem">
  Every natural number can be uniquely factorized (up to ordering) into its
  **prime factors**.
</CalloutBox>

<CalloutBox type="remark" title="">
  Notice that 1 is not included in the theorem‚Äôs statement, as it can be seen as
  a product of no primes.
</CalloutBox>

Another example of prime factorization:

<CalloutBox type="example" title="Prime factorization">
  $6615 = 3^3 \times 7^2 \times 5$
</CalloutBox>

---

Now let‚Äôs return to RSA and the **key generation process**.  
Bob can generate a pair of keys using the following steps:

<CalloutBox type="definition" title="RSA Key Generation">
  <ol>
    <li>Choose two primes: $p$ and $q$</li>
    <li>Compute $n = p \times q$</li>
    <li>Compute $\phi(n) = (p ‚àí 1)(q ‚àí 1)$</li>
    <li>Choose $e$ such that $1 < e < \phi(n)$ and $gcd(e, \phi(n)) = 1$</li>
    <li>Find $d$ such that $e \times d \equiv 1 \mod \phi(n)$</li>
    <li>The public key is $(e, n)$; the private key consists of $(d, p, q)$</li>
  </ol>
</CalloutBox>

Some of these steps rely on concepts we haven‚Äôt yet defined.  
Let‚Äôs walk through them one by one.

---

## Step 1: Choose two primes

Bob first chooses two distinct prime numbers: $p$ and $q$.

These primes should be large enough (at least 20 digits) to ensure the system‚Äôs security.  
It is **notoriously difficult** to factor the product of two large primes ‚Äî the basis of RSA‚Äôs strength.

---

## Step 2: Compute $n = p \times q$

This is straightforward ‚Äî $n$ is the product of the two primes.

---

## Step 3: Compute $\phi(n) = (p ‚àí 1)(q ‚àí 1)$

Here we introduce $\phi(n)$, the **Euler's totient function**.

<CalloutBox type="definition" title="Euler's Totient Function">
  Given a positive integer $n$, the totient function $\phi(n)$ counts the number
  of integers from $0$ to $n - 1$ that are **coprime** to $n$. By convention,
  $\phi(1) = 1$.
</CalloutBox>

<CalloutBox type="example" title="">
  $\phi(12) = 4$ because the integers $1, 5, 7$, and $11$ are coprime to $12$.
</CalloutBox>

But what does ‚Äúcoprime‚Äù mean?

Two positive integers are **coprime** if they have no common prime factors other than 1.

In particular, if $n$ is a prime number, then $\phi(n) = n - 1$.

Since $p$ and $q$ are distinct primes, they‚Äôre coprime ‚Äî so:  
$\phi(n) = (p ‚àí 1)(q ‚àí 1)$.

Note: computing $\phi(n)$ from just $n$ would require factoring $n$, which is computationally hard ‚Äî another pillar of RSA‚Äôs security.

---

## Step 4: Choose $e$ such that $1 < e < \phi(n)$ and $gcd(e, \phi(n)) = 1$

Now Bob must choose an **exponent** $e$.

It should satisfy:

- $1 < e < \phi(n)$
- $gcd(e, \phi(n)) = 1$

A common choice is $e = 2^{16} + 1$ (65,537) ‚Äî large enough for security, small enough for efficiency.

To check whether $e$ and $\phi(n)$ are coprime, we use the **greatest common divisor (gcd)**.

<CalloutBox type="definition" title="GCD">
  The **greatest common divisor** of two integers is the largest positive
  integer that divides both numbers without leaving a remainder.
</CalloutBox>

<CalloutBox type="example" title="GCD">
  The gcd of $12$ and $15$ is $3$, since it divides both without a remainder.
</CalloutBox>

To compute the gcd, Bob can use the **Euclidean algorithm**, one of the oldest known algorithms (from _Elements_, c. 300 BC):

<CalloutBox type="theorem" title="">
  If $a \neq 0$ and $b = aq + r$ for some $q$ and $r$, then $$ \gcd(a, b) =
  \gcd(a, r) $$
</CalloutBox>

Steps to compute it:

1. Let $a$ and $b$ be two positive integers (swap if $b > a$)
2. If $b = 0$, then $\gcd(a, b) = a$
3. Otherwise, replace $a$ with $b$, and $b$ with $a \% b$
4. Repeat until $b = 0$

The last non-zero remainder is the gcd.

```ts
function gcd(a, b) {
  return b === 0 ? a : gcd(b, a % b);
}
```

`%` is the **remainder operator** in JavaScript ‚Äî [see the specification here](https://262.ecma-international.org/5.1/#sec-11.5.2).

With this, Bob can algorithmically determine whether two integers are **coprime**:

<CalloutBox type="definition" title="Coprime">
  Two integers are <strong>coprime</strong> if their greatest common divisor
  (gcd) is 1.
</CalloutBox>

<CalloutBox type="example" title="Coprime">
  The integers 8 and 15 are coprime because their gcd is 1, meaning they have no
  common prime factors.
</CalloutBox>

## Step 5: Find $d$ such that $e \times d \equiv 1 \mod \phi(n)$

This equation means that $d$ is the **modular inverse** of $e$ modulo $\phi(n)$.

Let‚Äôs explore **modular arithmetic**, starting with the concept of **modular congruence**.

<CalloutBox type="definition" title="Modular Congruence">
  Let $a$ and $b$ be integers, and let $m &gt; 0$ be a positive integer.
  <br />
  We say that $a$ is <strong>congruent</strong> to $b$ modulo $m$ ‚Äî written as{" "}
  <br />
  <code>a \equiv b \mod m</code> ‚Äî if there exists an integer $k$ such that:
  <br />
  <code>a = b + km</code>
</CalloutBox>

In this context, $b$ is the **remainder** when dividing $a$ by $m$.

JavaScript doesn‚Äôt have a true `mod` operator ‚Äî only a **remainder operator** `%`, which behaves slightly differently for negative numbers.  
(See [this StackOverflow post](https://stackoverflow.com/questions/25726760/javascript-modular-arithmetic)).

To get a proper mod behavior, you can define your own function:

```js
const mod = (a, b) => ((a % b) + b) % b;
```

We can rewrite equation $e \times d = 1 \mod \phi(n)$ as $d = e^{-1} \mod \phi(n)$.
$e^{-1}$ is the modular inverse. The existence of a modular inverse is
ensured by the fact that $e$ and $\phi(n)$ are coprime (remember the previous step?).

So to compute $d$, we used the fact that there exists a modular inverse of e.
We want to find an alghorith to compute it.
In this [article](https://cp-algorithms.com/algebra/module-inverse.html)
The [extended euclidean alghorith](https://brilliant.org/wiki/extended-euclidean-algorithm/) is often used to find the multplicative inverse.
Anyway i will opt for another methos wich is central in understanding why the encryption/decription
system works so smootlhy.
The methos relies on the Euler's Theorem.

<CalloutBox type="theorem" title="Euler's Theorem">
  Let $m$ be a positive integer, now for any integer $a$ coprime to $m$, we have:
  $$
    a^{\phi(m)} = 1 \mod m
  $$
</CalloutBox>

Bob can use Euler's Theorem to calculate $e^{-1}$ since he know $\phi(n)$ (remebmer the factorization diffculty).

Now, the equation  
$e \times d \equiv 1 \mod \phi(n)$  
can be rewritten as:  
$d = e^{-1} \mod \phi(n)$

That is: $d$ is the **modular inverse** of $e$ modulo $\phi(n)$.

Such a modular inverse exists **only if** $e$ and $\phi(n)$ are coprime ‚Äî which, by construction, they are.

To compute $d$, Bob can use the **Extended Euclidean Algorithm**, a standard method for finding modular inverses.

- [Here‚Äôs a nice explanation](https://cp-algorithms.com/algebra/module-inverse.html)
- Or see [this one on Brilliant](https://brilliant.org/wiki/extended-euclidean-algorithm/)

However, there's another elegant method ‚Äî central to understanding how RSA works ‚Äî based on **Euler's Theorem**:

<CalloutBox type="theorem" title="Euler's Theorem">
  Let $m$ be a positive integer. For any integer $a$ that is coprime to $m$, we have:  
  $$a^{\phi(m)} \equiv 1 \mod m$$
</CalloutBox>

Since Bob knows $\phi(n)$ (thanks to his knowledge of $p$ and $q$), he can use Euler's Theorem to compute $e^{-1}$:

$$
e^{\phi(n)} \equiv 1 \mod n
$$

This implies:

$$
e^{\phi(n) - 1} \equiv e^{-1} \mod n
$$

So Bob can compute:

$$
d = e^{\phi(n) - 1} \mod \phi(n)
$$

to obtain the **modular inverse**.

> üìù $e^{\phi(n) - 1}$ is computed through exponentiation algorithm

> üìù In practice, modular inverses are computed using the extended Euclidean algorithm for performance, but **Euler's Theorem**
> provides the theoretical foundation that makes RSA possible.
