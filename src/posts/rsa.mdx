import CalloutBox from "@/components/CalloutBox";

# Understanding RSA

RSA is one of the first public-key encryption algorithms used and, for this reason, serves very well as a
pedagogical example to the reader who wants to explore **cryptography**.

In this post I intend to focus more on the mathematical side of it, specifically **number theory**.

Let's begin by understanding the system. RSA uses a pair of keys: one **public**, which can be shared openly, and one **private**, which must be kept secret by its owner.

The standard example involves Bob and Alice exchanging messages.
Since they want to encrypt their communication using RSA, each of them has the stated key pair.

Secure of the system, Alice wants to send a message to Bob. She uses Bob’s **public key** to **encrypt** the message.

At this point Bob, <u>and Bob only</u>, will then be able to **decrypt** the message and read it,
by using his **private-key**

The security of this system relies on the fact that Bob’s private key is known only to him.
The algorithm ensures that messages encrypted with the public key can only be decrypted using the
corresponding private key in a mathematically elegant and fascinating way called **modular arithmetic**.

Generating such public/private key pairs involves fundamental number theory concepts, particularly **prime numbers**. You may recall that a prime number is a **natural number** (positive integer) greater than 1 and divisible only by itself and 1.

<CalloutBox type="example" title="Prime factorization">
  3 and 7 are prime numbers, while 21 is not. It can be expressed as a product
  of primes: 3 × 7.
</CalloutBox>

The primes are the atoms of natural numbers. Each natural number can be constructed as a product of primes (factorization). This factorization is unique, up to the order of the factors.

<CalloutBox type="example" title="Prime factorization">
  $21 = 7 \times 3$ or $3 \times 7$
</CalloutBox>

This is stated as an important **theorem** called **Fundamental Theorem of Arithmetic** or **Unique Factorization Theorem**, in short **UFT**.

<CalloutBox type="theorem" title="Unique Factorization Theorem">
  Every natural number can be uniquely factorized, (up to ordering) by it's
  **prime facrtors**
</CalloutBox>

<CalloutBox type="remark" title="">
  Notice that 1 is not a included in the statement of the theorem, as it can be
  seen as a product of no primes.
</CalloutBox>

Here another example of prime factorization:

<CalloutBox type="example" title="Prime factorization">
  $6615 = 3^3 \times 7^2 \times 5$
</CalloutBox>

Getting back to the key generation process.
Bob can generate a pair of keys using the following steps:

<CalloutBox type="definition" title="RSA Key Generation">
  <ol>
    <li>
      Choose two primes: $p$ and $q$
    </li>
    <li>
      Compute $n = p \times q$
    </li>
    <li>Compute $\phi(n) = (p−1)(q−1)$</li>
    <li>
      Choose $e$ such that $1 < e < \phi(n)$ and 
      $gcd(e, \phi(n)) = 1$
    </li>
    <li>
      Find $d$ such that $e \times d = 1 \mod \phi(n)$
    </li>
    <li>
      $e$ and $n$ forms the public key, while, $d,p$ and $q$ the private key.
    </li>
  </ol>
</CalloutBox>

This is probably not very clear, since i haven't defined most of concepts.
Let's dig in step by step.

## Step 1: Choose two primes

The first step is to choose two distinct prime numbers, $p$ and $q$.
These primes should be large enough (at least 20 digits) to ensure the security of the system.
It's indeed notoriusly difficult to factorize the product of two large primes, which is the basis of RSA's
security.

## Step 2: Compute $n = p \times q$

I hope this is clear.

## Step 3: Compute $\phi(n) = (p−1)(q−1)$

Now here it's where things get more complicated.
We introduce $\phi(n)$ called the **Euler's totient function**.

<CalloutBox type="definition" title="Euler's totient function">
  Given a positive integeer $n$, the totient function $\phi(n)$, counts the
  number of integers from $0$ to $n-1$ that are coprime to $n$. By convention
  $\phi(1) = 1$.
</CalloutBox>

<CalloutBox type="example" title="">
  $\phi(12) = 4$. Since the integers $1, 5, 7$, and $11$ are coprime to $12$.
</CalloutBox>

Ok wait but what does it mean to be coprime? Well for now we can say that two positive integers are **coprime** if they have no common prime factors other than 1.

In particular if $n$ is a prime number, then $\phi(n) = n - 1$. Why?

Morover if p and q are coprime (notice that our p and q are distinct primes), it follows that $\phi(n) = (p−1)(q−1)$.
Notice that in order to compute $\phi(n)$ one must factorize it first wich is extremely hard.

## Step 4: Choose $e$ such that $1 < e < \phi(n)$ where $e$ is coprime to $\phi(n)$ ( $gcd(e, \phi(n)) = 1$ )

Bob now seeks for an **exponent** $e$.
Choosing $e$ such that $1 < e < \phi(n)$ should be clear, anyway a notyher fact to consider
here is that e should be large enough to e4nsure securenss but small enough to reduce time complexity.
The most commonly chosen value for $e$ is $2^{16} + 1$ (See Wikipedia).
Anyway, in order to determine that this two positive integers are coprime,
we introduce the **gcd** and claim two integers are coprime if $gcd(e, \phi(n)) = 1$.

<CalloutBox type="definition" title="GCD">
  The **greatest common divisor** (gcd) of two integers is the largest positive
  integer that divides both numbers without leaving a remainder.
</CalloutBox>

<CalloutBox type="example" title="GCD">
  The gcd of $12$ and $15$ is $3$, since $3$ is the largest number that divides
  both without a remainder.
</CalloutBox>

To compute the gcd of two integers, we can use the **Euclidean algorithm** descibed in "Elements" around 300 BC
(yes one of the oldest and still used algorithm).
The algorithm is based on the following principle.

<CalloutBox type="theorem" title="">
  Given integers $a$ and $b$ with $a \neq 0$ and $b=aq+r$, for some $q$ and $r$
  (quiotient ant remainder), then $$ gcd(a,b)=gcd(a,r) $$
</CalloutBox>
Break it in steps: 1. Take two integers $a$ and $b$. (if $b \leq a$ swap them) 2.
If $b$ is 0, then the gcd is $a$. 3. Otherwise, replace $a$ with $b$ and $b$ with
$a % b$ (the remainder $r$ of the division of $a$ by $b$). 4. Repeat steps 2 and
3 until $b$ becomes 0.

The gcd is the last non-zero remainder, which is the largest positive integer that divides both $a$ and $b$.

```javascript
function gcd(a, b) {
  return b === 0 ? a : gcd(b, a % b);
}
```

Now we can thus algorithically determine whether two integers are coprime:

<CalloutBox type="definition" title="Coprime">
  Two integers are coprime if their greatest common divisor (gcd) is 1.
</CalloutBox>

<CalloutBox type="example" title="Coprime">
  The integers 8 and 15 are coprime because their gcd is 1, meaning they have no
  common prime factors.
</CalloutBox>

## Step 5: Find $d$ such that $e \times d = 1 \mod \phi(n)$

The equation $e \times d = 1 \mod \phi(n)$ must be read as $e \times d$ is congruent $1$ modulo $m$.
Her begin the story related to modular arithmetic.
We first define what it means **mod** in this context.

<CalloutBox type="definition" title="Modular Congruence">
  Let $a, b$ be integers and $m$ a positive integers greater then zero. $$ a = b
  \mod m $$
</CalloutBox>
